-module(async).

-behaviour(application).

-export([start/0, start/2, stop/1]).
-export([create/0, init/2, stop/0, getdb/1, putdb/2, lql/1, view_RT/2, view/2]).

-include("records.hrl").

-define(START, $s).
-define(PUT, $p).
-define(GET, $g).
-define(VIEW, $v).
-define(PROCESS, $r).
-define(DUMP, $d).
-define(LQL, $l).
-define(STOP, $o).

start() ->
	application:start(reloader),
	application:start(lethedb).

% HINT: Some great ideas here: https://github.com/uwiger/gproc/tree/master/src
start(_StartType, _StartArgs) ->
	reloader:start(),
	mnezia:start(),

	code:add_path("../lethedb"),
	DriverPath = filename:join([code:priv_dir("lethedb"), "lib"]),
	
	case erl_ddll:load_driver(DriverPath, "lethe_drv") of
		ok -> ok;
		{error, already_loaded} -> ok;
		{error, Message} -> exit(erl_ddll:format_error(Message))
	end,
	spawn(lethedb, create, []),

	lethedb_sup:start_link().

create() ->
	register(lethe, self()),
	Port = open_port({spawn_driver, lethe_drv}, [binary]),
	
	% create an ETS table in order to store the PID
	% we used to return the PID and let the caller to everything
	% but this is cleaner
	ets:new(lethe_pid_table, [named_table, protected, set, {keypos, 1}, {read_concurrency, true}]),
	ets:insert(lethe_pid_table, {port, Port}),
	loop().

init(NumOfApps, NumOfKeyCells) ->	
	collect_manager:start(),
	call_port(?START, integer_to_list(NumOfApps), integer_to_list(NumOfKeyCells)).

call_port(Command, Key, Value) ->
	lethe ! {Command, self(), Key, Value},
	receive
		{ok, Result} ->
			{ok, Result};
		Error ->
			io:format("ERROR ~p ~n", [Error]),
			{ok, retry}
	end.

stop() ->
	lethe ! stop,
	unregister(lethe).

%% For realtime Views
%% The Collector is always called, in order to always have
%% the latest data
view_RT(AppKey, ViewName) ->
	gc_collect(AppKey, lunatic),
	view(AppKey, ViewName).

% For other Views (maybe historical?)
% The collector is not connected with this call
view(AppKey, ViewName) ->
	call_port(?VIEW, AppKey, ViewName).

gc_collect(AppKey, Strategy) ->
	collect_manager:collect(AppKey, 
							fun(Akey) ->
									io:format("Process file ~n", []),
									process(Akey),
								%	io:format("Dump file ~n", []),
								%	dump(Akey),
									io:format("Functions ok ~n", []),
									all_good
							end, 
						   Strategy).

process(AppKey) ->
	call_port(?PROCESS, AppKey, '_').

dump(AppKey) ->
	call_port(?DUMP, AppKey, '_').

putdb(AppKey, Value) ->	
	gc_collect(AppKey, normal),
	[{_, Port}] = ets:lookup(lethe_pid_table, port),

	port_command(Port, term_to_binary({?PUT, AppKey, Value})).

lql(Query) ->	
	call_port(?LQL, Query, '_').

getdb(AppKey) ->	
	call_port(?GET, AppKey, '_').

lethe_response(Caller) ->
	receive 
		Data ->
			Caller ! Data
	after
		5000 ->
		    % failed to get a response from lethe
			failed
	end.

	
 loop() ->
 	receive
 		{Command, Caller, Key, Value} ->
 			[{_, Port}] = ets:lookup(lethe_pid_table, port),
 			port_command(Port, term_to_binary({Command, Key, Value})),
 			lethe_response(Caller),
 			loop();
 		stop ->
 			[{_, Port}] = ets:lookup(lethe_pid_table, port),
 			Port ! {self(), close},
 			receive
 				{closed} ->
 					collect_manager:stop(),
 					exit(normal)
 			end
 	end.


stop(_State) ->
	mnezia:stop(),

	call_port(?STOP, '_', '_'),

	lethe ! stop,
	receive
		Result ->
			Result
	end.

